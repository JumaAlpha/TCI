<div class="typing-locked-section">
    <div class="typing-locked-bg"></div>
    
    <!-- Primary Text (Fixed) -->
    <h1 class="typing-primary">We are</h1>
    
    <!-- Secondary Text Container -->
    <div class="typing-secondary-container">
        <div class="typing-secondary" id="typingText">
            <span id="typingContent">a christ community</span>
            <span class="typing-cursor"></span>
        </div>
    </div>
    
    <!-- Progress Indicator -->
    <div class="typing-progress-indicator">
        <div class="progress-dot active" data-index="0"></div>
        <div class="progress-dot" data-index="1"></div>
        <div class="progress-dot" data-index="2"></div>
        <div class="progress-dot" data-index="3"></div>
    </div>
    
    <!-- Scroll Instruction -->
    <div class="typing-instruction">
        <span>Scroll to change text</span>
        <div class="scroll-arrow">â†“</div>
    </div>
</div>

<!-- Scroll Indicator (Global) -->
<div class="scroll-indicator">
    Scroll
    <div class="scroll-line"></div>
</div>

<style>
/* Color Variables */
:root {
    --lime-green: #32cd32;
    --lime-green-light: #7cfc00;
    --lime-green-dark: #228b22;
    --orange: #ff8c00;
    --orange-light: #ffa500;
    --orange-dark: #ff4500;
    --white: #ffffff;
    --black: #000000;
    --gray-dark: #1a1a1a;
    --gray-light: #333333;
}

/* Scroll-Locked Typing Section - Step-based scrolling */
.typing-locked-section {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: #000;
    z-index: 6;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.typing-locked-section.active {
    opacity: 1;
    pointer-events: all;
}

.typing-locked-bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(circle at 20% 30%, rgba(50, 205, 50, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255, 140, 0, 0.1) 0%, transparent 50%);
    z-index: -1;
}

.typing-primary {
    font-size: clamp(3rem, 8vw, 6rem);
    font-weight: 900;
    color: var(--white);
    text-align: center;
    margin-bottom: 40px;
    position: relative;
    opacity: 0.9;
}

.typing-secondary-container {
    position: relative;
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
}

.typing-secondary {
    font-size: clamp(2.5rem, 6vw, 4rem);
    font-weight: 900;
    color: var(--lime-green);
    text-align: center;
    min-height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    width: 100%;
}

.typing-cursor {
    display: inline-block;
    width: 3px;
    height: 1.2em;
    background-color: var(--orange);
    margin-left: 8px;
    animation: blink 1s infinite;
    vertical-align: middle;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}

/* Progress indicator with dots */
.typing-progress-indicator {
    display: flex;
    gap: 20px;
    margin-top: 60px;
    position: relative;
}

.progress-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: rgba(255, 140, 0, 0.3);
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
}

.progress-dot.active {
    background: var(--lime-green);
    transform: scale(1.4);
    box-shadow: 0 0 15px rgba(50, 205, 50, 0.5);
}

.progress-dot::after {
    content: attr(data-index);
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255, 140, 0, 0.5);
    font-size: 12px;
    font-weight: 700;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.progress-dot:hover::after {
    opacity: 1;
}

/* Scroll instruction */
.typing-instruction {
    position: absolute;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    color: var(--orange);
    font-size: 14px;
    letter-spacing: 2px;
    text-transform: uppercase;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

.scroll-arrow {
    font-size: 24px;
    color: var(--lime-green);
    animation: bounce 2s infinite;
    cursor: pointer;
}

@keyframes bounce {
    0%, 100% { 
        transform: translateY(0);
        opacity: 0.7;
    }
    50% { 
        transform: translateY(8px);
        opacity: 1;
    }
}

/* Animation for text change */
@keyframes textFadeIn {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes textFadeOut {
    0% {
        opacity: 1;
        transform: translateY(0);
    }
    100% {
        opacity: 0;
        transform: translateY(-20px);
    }
}

.typing-text-enter {
    animation: textFadeIn 0.5s ease forwards;
}

.typing-text-exit {
    animation: textFadeOut 0.5s ease forwards;
}

/* Scroll indicator styles */
.scroll-indicator {
    position: fixed;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    color: var(--white);
    font-size: 12px;
    letter-spacing: 3px;
    text-transform: uppercase;
    z-index: 10;
    transition: opacity 0.5s ease;
    pointer-events: none;
}

.scroll-indicator.hidden {
    opacity: 0;
    visibility: hidden;
}

.scroll-line {
    width: 1px;
    height: 60px;
    background: rgba(255, 255, 255, 0.5);
    margin: 10px auto 0;
    position: relative;
    overflow: hidden;
}

.scroll-line::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 20px;
    background: var(--lime-green);
    animation: scrollLine 2s infinite ease-in-out;
}

/* Override conflicting styles from common.css */
.typing-locked-section .typing-secondary {
    font-size: clamp(2.5rem, 6vw, 4rem) !important;
    font-weight: 900 !important;
    color: var(--lime-green) !important;
    text-align: center !important;
    min-height: 80px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    position: relative !important;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
    width: 100% !important;
    opacity: 1 !important;
    transform: none !important;
}

.typing-locked-section .typing-primary {
    font-size: clamp(3rem, 8vw, 6rem) !important;
    font-weight: 900 !important;
    color: var(--white) !important;
    text-align: center !important;
    margin-bottom: 40px !important;
    position: relative !important;
    opacity: 1 !important;
}

.typing-locked-section .typing-secondary-container {
    position: relative !important;
    min-height: 120px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    width: 100% !important;
}

@keyframes scrollLine {
    from {
        top: -20px;
    }
    to {
        top: 100%;
    }
}
</style>

<script>
    // Self-contained typing section functionality
(function() {
    'use strict';
    
    // Wait for component to be loaded into DOM
    const checkElement = setInterval(() => {
        const typingSection = document.querySelector('.typing-locked-section');
        if (typingSection) {
            clearInterval(checkElement);
            initTypingSection();
        }
    }, 100);
    
    function initTypingSection() {
        // Elements
        const typingSection = document.querySelector('.typing-locked-section');
        const typingContent = document.getElementById('typingContent');
        const progressDots = document.querySelectorAll('.progress-dot');
        const scrollArrow = document.querySelector('.scroll-arrow');
        
        // Configuration
        const secondaryTexts = [
            "a christ community",
            "family",
            "Faith driven Church",
            "Triumphant Church"
        ];
        
        // State
        let currentTextIndex = 0;
        let isTypingSectionActive = false;
        let isAnimating = false;
        let scrollTimeout = null;
        let typingScrollStart = 0;
        let typingScrollEnd = 0;
        let heroHeight = window.innerHeight;
        let lastTouchY = 0;
        let hasCompletedAllTexts = false;
        
        // Initialize
        setupTypingSection();
        
        function setupTypingSection() {
            // Calculate scroll boundaries - align with external component
            heroHeight = window.innerHeight;
            typingScrollStart = heroHeight * 4.5;
            typingScrollEnd = heroHeight * 5.5;
            
            // Set initial text
            updateTypingText(0);
            
            // Add event listeners
            addEventListeners();
            
            // Start scroll monitoring
            monitorScroll();
        }
        
        function addEventListeners() {
            // Mouse wheel for step-based scrolling
            window.addEventListener('wheel', handleTypingScroll, { passive: false });
            
            // Keyboard navigation
            window.addEventListener('keydown', handleTypingKeys);
            
            // Touch for mobile
            window.addEventListener('touchstart', handleTouchStart, { passive: true });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            
            // Click events for progress dots
            progressDots.forEach(dot => {
                dot.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    if (index !== currentTextIndex && !isAnimating) {
                        changeTypingText(index);
                    }
                });
            });
            
            // Resize handling
            window.addEventListener('resize', handleResize);
            
            // Scroll arrow click
            if (scrollArrow) {
                scrollArrow.addEventListener('click', () => {
                    if (currentTextIndex < secondaryTexts.length - 1 && !isAnimating) {
                        changeTypingText(currentTextIndex + 1);
                    }
                });
            }
        }
        
        function handleTypingScroll(e) {
            if (!isTypingSectionActive) return;
            
            // Get current scroll position
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            const isInTypingSection = scrollY >= typingScrollStart && scrollY <= typingScrollEnd;
            
            if (!isInTypingSection || isAnimating) return;
            
            // Determine direction
            const direction = e.deltaY > 0 ? 'down' : 'up';
            
            // Check if we can scroll to next/previous section
            if (direction === 'down' && currentTextIndex === secondaryTexts.length - 1) {
                // On last text and scrolling down - allow scroll to next section
                // No preventDefault, let natural scroll happen
                updateScrollInstruction("Scroll to exit section");
                hasCompletedAllTexts = true;
                return;
            } else if (direction === 'up' && currentTextIndex === 0) {
                // On first text and scrolling up - allow scroll to previous section
                // No preventDefault, let natural scroll happen
                updateScrollInstruction("Scroll to previous section");
                return;
            }
            
            // Otherwise, handle text navigation
            e.preventDefault();
            
            if (direction === 'down' && currentTextIndex < secondaryTexts.length - 1) {
                // Scroll down - next text
                changeTypingText(currentTextIndex + 1);
            } else if (direction === 'up' && currentTextIndex > 0) {
                // Scroll up - previous text
                changeTypingText(currentTextIndex - 1);
            }
            
            // Add slight scroll movement for feedback
            const scrollAmount = direction === 'down' ? 80 : -80;
            let newScrollY = scrollY + scrollAmount;
            
            // Clamp to typing section boundaries
            newScrollY = Math.max(typingScrollStart, Math.min(typingScrollEnd, newScrollY));
            
            window.scrollTo({ top: newScrollY, behavior: 'smooth' });
            
            // Set timeout to prevent rapid scrolling
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                isAnimating = false;
            }, 500);
        }
        
        function handleTypingKeys(e) {
            if (!isTypingSectionActive || isAnimating) return;
            
            // Arrow down or space for next text
            if (e.key === 'ArrowDown' || e.key === ' ' || e.key === 'PageDown') {
                e.preventDefault();
                if (currentTextIndex < secondaryTexts.length - 1) {
                    changeTypingText(currentTextIndex + 1);
                } else {
                    // Last text - scroll to next section
                    scrollToNextSection();
                }
            }
            // Arrow up for previous text
            else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
                e.preventDefault();
                if (currentTextIndex > 0) {
                    changeTypingText(currentTextIndex - 1);
                } else {
                    // First text - scroll to previous section
                    scrollToPreviousSection();
                }
            }
            // Number keys 1-4 for direct navigation
            else if (e.key >= '1' && e.key <= '4') {
                e.preventDefault();
                const index = parseInt(e.key) - 1;
                if (index < secondaryTexts.length && index !== currentTextIndex) {
                    changeTypingText(index);
                }
            }
            // Enter key for next
            else if (e.key === 'Enter') {
                e.preventDefault();
                if (currentTextIndex < secondaryTexts.length - 1) {
                    changeTypingText(currentTextIndex + 1);
                } else {
                    // Last text - scroll to next section
                    scrollToNextSection();
                }
            }
        }
        
        // Touch handling for mobile
        let touchStartY = 0;
        let isTouchScrolling = false;
        
        function handleTouchStart(e) {
            if (!isTypingSectionActive) return;
            touchStartY = e.touches[0].clientY;
            lastTouchY = touchStartY;
            isTouchScrolling = false;
        }
        
        function handleTouchMove(e) {
            if (!isTypingSectionActive || isAnimating) return;
            
            const touchY = e.touches[0].clientY;
            const deltaY = lastTouchY - touchY;
            lastTouchY = touchY;
            
            // Check if we're at boundaries
            const atFirstText = currentTextIndex === 0;
            const atLastText = currentTextIndex === secondaryTexts.length - 1;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            
            // Only handle if we're within typing section
            const isInTypingSection = scrollY >= typingScrollStart && scrollY <= typingScrollEnd;
            if (!isInTypingSection) return;
            
            // Prevent default to stop page scroll
            e.preventDefault();
            
            // Swipe detection for text change
            if (Math.abs(touchStartY - touchY) > 50 && !isTouchScrolling) {
                isTouchScrolling = true;
                
                if (deltaY > 5 && !atLastText) {
                    // Swipe up - next text
                    changeTypingText(currentTextIndex + 1);
                    return;
                } else if (deltaY < -5 && !atFirstText) {
                    // Swipe down - previous text
                    changeTypingText(currentTextIndex - 1);
                    return;
                }
            }
            
            // If at boundaries, allow scroll to next/previous section
            if (atLastText && deltaY > 20) {
                // On last text and strong swipe down - scroll to next section
                scrollToNextSection();
                return;
            } else if (atFirstText && deltaY < -20) {
                // On first text and strong swipe up - scroll to previous section
                scrollToPreviousSection();
                return;
            }
            
            // Small scroll adjustments
            let newScrollY = scrollY + deltaY * 2;
            newScrollY = Math.max(typingScrollStart, Math.min(typingScrollEnd, newScrollY));
            window.scrollTo({ top: newScrollY, behavior: 'auto' });
        }
        
        function scrollToNextSection() {
            // Scroll to section after typing section
            const nextSectionStart = typingScrollEnd + heroHeight * 0.1;
            window.scrollTo({ top: nextSectionStart, behavior: 'smooth' });
            updateScrollInstruction("Scrolling to next section...");
        }
        
        function scrollToPreviousSection() {
            // Scroll to section before typing section
            const previousSectionEnd = typingScrollStart - heroHeight * 0.1;
            window.scrollTo({ top: previousSectionEnd, behavior: 'smooth' });
            updateScrollInstruction("Scrolling to previous section...");
        }
        
        function updateScrollInstruction(text) {
            const instruction = document.querySelector('.typing-instruction span');
            if (instruction) {
                instruction.textContent = text;
                // Reset after 2 seconds
                setTimeout(() => {
                    if (currentTextIndex === secondaryTexts.length - 1 && hasCompletedAllTexts) {
                        instruction.textContent = "Scroll to exit section";
                    } else {
                        instruction.textContent = "Scroll to change text";
                    }
                }, 2000);
            }
        }
        
        function changeTypingText(index) {
            if (index < 0 || index >= secondaryTexts.length || isAnimating) return;
            
            isAnimating = true;
            currentTextIndex = index;
            
            // Update completion state
            hasCompletedAllTexts = (index === secondaryTexts.length - 1);
            
            // Update scroll instruction based on position
            if (index === secondaryTexts.length - 1) {
                updateScrollInstruction("Scroll to exit section");
            } else if (index === 0) {
                updateScrollInstruction("Scroll to previous section");
            } else {
                updateScrollInstruction("Scroll to change text");
            }
            
            // Animate text change
            if (typingContent) {
                typingContent.classList.add('typing-text-exit');
                
                setTimeout(() => {
                    // Update text
                    typingContent.textContent = secondaryTexts[index];
                    // Remove exit class and add enter class
                    typingContent.classList.remove('typing-text-exit');
                    typingContent.classList.add('typing-text-enter');
                    
                    // Update progress dots
                    updateProgressDots(index);
                    
                    // Calculate and set scroll position
                    const textCount = secondaryTexts.length;
                    if (textCount > 1) {
                        const progress = index / (textCount - 1);
                        const newScrollY = typingScrollStart + (typingScrollEnd - typingScrollStart) * progress;
                        window.scrollTo({ top: newScrollY, behavior: 'smooth' });
                    }
                    
                    // Remove enter animation after completion
                    setTimeout(() => {
                        typingContent.classList.remove('typing-text-enter');
                        isAnimating = false;
                    }, 500);
                }, 300);
            } else {
                isAnimating = false;
            }
        }
        
        function updateTypingText(index) {
            if (index < 0 || index >= secondaryTexts.length) return;
            
            currentTextIndex = index;
            hasCompletedAllTexts = (index === secondaryTexts.length - 1);
            
            if (typingContent) {
                typingContent.textContent = secondaryTexts[index];
            }
            updateProgressDots(index);
            
            // Update scroll instruction
            if (index === secondaryTexts.length - 1) {
                updateScrollInstruction("Scroll to exit section");
            } else if (index === 0) {
                updateScrollInstruction("Scroll to previous section");
            }
        }
        
        function updateProgressDots(index) {
            progressDots.forEach((dot, dotIndex) => {
                if (dotIndex === index) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }
        
        function monitorScroll() {
            let lastScrollY = window.pageYOffset || document.documentElement.scrollTop;
            let ticking = false;
            
            function checkScroll() {
                const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                
                // Check if we're in typing section
                const isInTypingSection = scrollY >= typingScrollStart && scrollY <= typingScrollEnd;
                
                // Activate/deactivate typing section
                if (isInTypingSection && !isTypingSectionActive) {
                    isTypingSectionActive = true;
                    typingSection.classList.add('active');
                    // Hide main scroll indicator if it exists
                    const mainScrollIndicator = document.querySelector('.scroll-indicator:not(.typing-instruction)');
                    if (mainScrollIndicator) {
                        mainScrollIndicator.classList.add('hidden');
                    }
                    
                    // Reset completion state when entering typing section
                    hasCompletedAllTexts = (currentTextIndex === secondaryTexts.length - 1);
                } else if (!isInTypingSection && isTypingSectionActive) {
                    isTypingSectionActive = false;
                    typingSection.classList.remove('active');
                    // Show main scroll indicator if at top
                    const mainScrollIndicator = document.querySelector('.scroll-indicator:not(.typing-instruction)');
                    if (mainScrollIndicator && scrollY < heroHeight * 0.1) {
                        mainScrollIndicator.classList.remove('hidden');
                    }
                    
                    // Reset scroll instruction when leaving
                    const instruction = document.querySelector('.typing-instruction span');
                    if (instruction) {
                        instruction.textContent = "Scroll to change text";
                    }
                }
                
                // If not in typing section, skip further processing
                if (!isInTypingSection) {
                    ticking = false;
                    return;
                }
                
                // Calculate progress for typing section
                const typingProgressValue = (scrollY - typingScrollStart) / (typingScrollEnd - typingScrollStart);
                
                // Snap to nearest text based on scroll position (backup for direct scroll)
                const textCount = secondaryTexts.length;
                if (textCount > 1) {
                    const calculatedIndex = Math.round(typingProgressValue * (textCount - 1));
                    
                    // Only update if not currently animating and index has changed
                    if (calculatedIndex !== currentTextIndex && !isAnimating) {
                        updateTypingText(calculatedIndex);
                    }
                }
                
                lastScrollY = scrollY;
                ticking = false;
            }
            
            window.addEventListener('scroll', function() {
                if (!ticking) {
                    window.requestAnimationFrame(checkScroll);
                    ticking = true;
                }
            });
            
            // Initial check
            checkScroll();
        }
        
        function handleResize() {
            heroHeight = window.innerHeight;
            typingScrollStart = heroHeight * 4.5;
            typingScrollEnd = heroHeight * 5.5;
        }
        
        // Cleanup function
        function cleanup() {
            window.removeEventListener('wheel', handleTypingScroll);
            window.removeEventListener('keydown', handleTypingKeys);
            window.removeEventListener('touchstart', handleTouchStart);
            window.removeEventListener('touchmove', handleTouchMove);
            window.removeEventListener('resize', handleResize);
            if (scrollTimeout) clearTimeout(scrollTimeout);
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);
    }
})();
</script>